use crate::anonymity::secret_sharing::*;
use crate::anonymity::logic::*;
use crate::anonymity::callbacks::*;
use crate::consensus::client::{ClientTransport, Client};
use crate::consensus::types::*;
use std::{hash::Hash, pin::Pin, rc::Rc};
use std::collections::{VecDeque, HashMap};
use futures::{Stream, StreamExt};
use tokio::sync::{watch, mpsc, oneshot};
use tokio::task::JoinHandle;
use rand::distributions::{Distribution, Uniform};
use tokio_stream::StreamMap;
use tracing_futures::Instrument;
use derivative;
use std::sync::Arc;


/// Combines NewRound streams(ideally from many servers) onto a single stream, allowing to handle events
/// from many servers in case some are faulty
pub fn combined_subscriber<V: Value>(receivers: impl Iterator<Item = Pin<Box<dyn Stream<Item = NewRound<V>>>>>) 
    -> Pin<Box<dyn Stream<Item = NewRound<V>>>> {

    let mut stream_map = StreamMap::new();

    for (i, stream) in (0 ..).zip(receivers) {
        let _res = stream_map.insert(i, stream);
        assert!(_res.is_none());
    }

    let mut next_round_to_send = 0;
    let combined_stream = stream_map.filter_map(move |(_, round)| {
        let res = if round.round >= next_round_to_send {
            next_round_to_send = round.round + 1;
            Some(round)
        } else { None };
        futures::future::ready(res)
    });

    Box::pin(combined_stream)
}


#[derive(Derivative)]
#[derivative(Debug)]
/// Handles logic of sending a value anonymously
struct AnonymousClientInner<V: Value + Hash, CT: ClientTransport<AnonymityMessage<V>>> {
    #[derivative(Debug="ignore")]
    mut_client: Client<CT, AnonymityMessage<V>>,

    #[derivative(Debug="ignore")]
    client: Arc<Client<CT, AnonymityMessage<V>>>,

    #[derivative(Debug="ignore")]
    config: Arc<Config>,

    #[derivative(Debug="ignore")]
    phantom: std::marker::PhantomData<V>,

    pub client_name: String

}

#[derive(Derivative)]
#[derivative(Debug)]
pub struct AnonymousClient<V: Value + Hash> {
    #[derivative(Debug="ignore")]
    handle: JoinHandle<()>,

    #[derivative(Debug="ignore")]
    send_anonym_queue: mpsc::UnboundedSender<(V, CommitResolver)>,

    pub client_name: String,

}


#[derive(Debug, Clone, Copy)]
pub struct CommitResult { 
    pub round: usize,
    pub channel: usize
}

type CommitResolver = oneshot::Sender<CommitResult>;

#[derive(Derivative)]
#[derivative(Debug)]
struct ToBeCommitted<V> {
    value: V,
    channel_and_round: Option<(usize, usize)>,

    #[derivative(Debug="ignore")]
    resolver: CommitResolver
}

fn was_value_committed<V: Value>(new_round: &NewRound<V>, last_sent: &ToBeCommitted<V>) -> Option<()> {
    {
        let (channel, round) = last_sent.channel_and_round?;
        if new_round.round != round + 1 {
            return None
        }
        let recon_res = new_round.last_reconstruct_results.as_ref()?;
        if let Ok(val) = &recon_res[channel] {
            // if the client is faulty, he might've sent a value via the channel
            // but it wasn't mixed during reconstruction, and another client had gotten its
            // value committed to that channel.
            // 
            // NOTE: in case another client has sent an identical value, no way to tell if it's his or ours
            // other than adding some unique one-time identifier generated by the client when the message was sent.
            if val != &last_sent.value {
                return None;
            }
            assert_eq!(val, &last_sent.value);
            info!("Client saw that his value {:?} was committed at round {}", val, round);
            return Some(());
        }
        return None;
    }
}

impl <V: Value + Hash> AnonymousClient<V> {
    pub fn new<CT: ClientTransport<AnonymityMessage<V>>>(client_transport: CT, 
        config: Arc<Config>, client_name: String,
        mut event_recv: Pin<Box<dyn Stream<Item = NewRound<V>>>>) -> Self 
    {
        let mut client = AnonymousClientInner::new(client_transport, config, client_name.clone());

        let (tx, mut rx) = mpsc::unbounded_channel();


        let orig_tx = tx.clone();

        let handle = tokio::task::spawn_local(async move {
            // contains values in the order they were 
            let mut uncommited_queue = VecDeque::<ToBeCommitted<V>>::new();
            let mut round = 0usize;

            let mut sent_for_round = -1i64;

            // used to trigger sending of shares every new round, if any
            let (notify, mut notify_rx) = watch::channel(());

            loop {
               tokio::select! {
                   // handle client requests
                   Some((value, resolver)) = rx.recv() => {
                       uncommited_queue.push_back(ToBeCommitted {
                           value, channel_and_round: None, resolver: resolver
                       });
                       notify.send(()).unwrap();
                   },
                
                   // try sending a new value for the current round
                   Ok(()) = notify_rx.changed() => {
                       if let Some(tbc) = uncommited_queue.get_mut(0) {
                           if sent_for_round < round as i64 {
                                sent_for_round = round as i64;
                                info!("Found that its time to submit my value {:?}, at round {}", tbc, round);
                                if let Ok((sec_channel, succ_nodes)) = client.send_anonymously(tbc.value.clone(), round).await {
                                        tbc.channel_and_round = Some((sec_channel, round));
                                        let succ_count = succ_nodes.len();
                                        info!("Sent {:?} for round {} via channel {} to {} nodes: {:?}", tbc.value, round, sec_channel, succ_count, succ_nodes);
                                } else {
                                    error!("Client Couldn't send {:?}", tbc.value);
                                }
                           }
                       } else {
                           // TODO: send a zero value instead

                       }
                   },

                   // handle new rounds
                   Some(new_round) = event_recv.next() => {
                       trace!("Saw new round: {:?}", new_round);

                       // ignore delayed new-round messages
                       if new_round.round < round {
                           continue;
                       }
                       // check if the previous value was committed
                       if !uncommited_queue.is_empty() && was_value_committed(&new_round, &uncommited_queue[0]).is_some() {
                           let tbc = uncommited_queue.pop_front().unwrap();
                           let (channel, round) = tbc.channel_and_round.unwrap();
                           info!("Gonna try and send {:?}", tbc);
                           tbc.resolver.send(CommitResult { round, channel}).unwrap();
                       }


                       round = new_round.round;
                       // try sending an uncommitted value
                       notify.send(()).unwrap();
                   }
               } 
            }
        }.instrument(info_span!("anonym_client_loop", name=?client_name.clone())));

        AnonymousClient {
            handle,
            send_anonym_queue: orig_tx,
            client_name
        }

    }


    #[instrument]
    pub async fn send_anonymously(&mut self, value: V) -> Result<CommitResult, anyhow::Error> {
        let (tx, rx) = oneshot::channel();
        self.send_anonym_queue.send((value, tx))?;
        let res = rx.await.unwrap();
        Ok(res)
    }
}

impl <CT: ClientTransport<AnonymityMessage<V>>, V: Value + Hash> AnonymousClientInner<V, CT> {
    fn new(client_transport: CT, config: Arc<Config>, client_name: String) -> Self {
        AnonymousClientInner {
            mut_client: Client::new(client_name.clone(), client_transport.clone(), config.num_nodes),
            client: Arc::new(Client::new(client_name.clone(), client_transport, config.num_nodes)),
            config,
            phantom: Default::default(),
            client_name
        }
    }

    /// Sends a value anonymously, returning the channel via it was sent and the nodes that got the shares
    #[instrument]
    async fn send_anonymously(&mut self, value: V, round: usize) -> Result<(usize, Vec<Id>), anyhow::Error> {
        // note that thread_rng is crypto-secure
        let val_channel = Uniform::new(0, self.config.num_channels).sample(&mut rand::thread_rng());
        let secret_val = encode_secret(value)?;
        let zero_val = encode_zero_secret();


        // create 'd' collections of shares, one for each server
        let chan_secrets = (0.. self.config.num_channels).map(|chan| {
            let secret = if chan == val_channel { &secret_val } else { &zero_val };
            let threshold = self.config.threshold as u64;
            let num_nodes = self.config.num_nodes as u64;
            create_share(secret.clone(), threshold, num_nodes)
        }).collect::<Vec<_>>();



        // create tasks for sending batches of channels for every server
        let client = self.client.clone();
        let timeout_duration = self.config.phase_length / 2;
        let batch_futs = (0.. self.config.num_nodes).map(|node_id| {
            let batch = chan_secrets.iter().map(|chan_shares| {
                chan_shares[node_id].to_bytes()
            }).collect();

            let client = client.clone();
            let client_name = self.client_name.clone();
            async move {
                on_anonym_client_send(&client_name, round, Some(node_id));
                let submit_fut = client.submit_without_commit(node_id, AnonymityMessage::ClientShare {
                    channel_shares: batch, client_name, round
                }); //.await.map_err(|e| e.context(format!("while sending to server ID {}", node_id)));
                let res = tokio::time::timeout(timeout_duration, submit_fut).await;
                (match res {
                    Ok(inner) => { inner }
                    Err(_elapsed) => { Err(anyhow::anyhow!("Timeout of duration {:?} elapsed while sending to {}", timeout_duration, node_id)) }
                }, node_id)
            }
        });

        info!("Client {} beginning to send shares for round {} via channel {}", self.client_name, round, val_channel);
        let ls = tokio::task::LocalSet::new();
        let succ_nodes = ls.run_until(async move {
            let mut handles = batch_futs.into_iter().map(|f| tokio::task::spawn_local(f)).collect::<Vec<_>>();
            let mut succ_nodes = Vec::new();
            while !handles.is_empty() {
                match futures::future::select_all(handles).await {
                    (Ok((Err(e), node_id)), _index, remaining) => {
                        trace!("Got an error while sending shares to servers {}: {:?}", node_id, e);
                        handles = remaining;
                    },
                    (Err(e), _index, remaining) => {
                        error!("Got an error while joining send-share task: {:?}", e);
                        handles = remaining;
                    },
                    (Ok((Ok(_res), node_id)), _index, remaining) => {
                        succ_nodes.push(node_id);
                        handles = remaining;
                    }
                }
            }
            return succ_nodes;
        }).await;


        on_anonym_client_send(&self.client_name, round, None);
        info!("Node {} submitting liveness for round {}", self.client_name, round);
        match self.mut_client.submit_value(AnonymityMessage::ClientNotifyLive { client_name: self.client_name.clone(), round: round }).await {
            Ok(_) => {}
            Err(e) => { error!("Couldn't notify that I am live to some servers for round {}: {:?}", round, e) }
        }

        Ok((val_channel, succ_nodes))
    }
}