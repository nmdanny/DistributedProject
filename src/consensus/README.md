# Exercise 2 - Synchronous consensus, n > 2f



The idea is to use the following algorithm, which is a simplification of Paxos. It has a simpler concept of leaders


Suppose a client(/client node) wants to propose a value `x`, it will calculate `slot` based on its log length, and broadcast
`propose(slot, x)` to all nodes but itself. 

For simplicity, assume all `x`'s generated by clients are unique (e.g, they include some random UUID)

- Whenever a node receives `propose(slot, x)`
  - Lock `proposeHandler`
  - If `slot` is already committed, or if the node already handled `propose(slot,x)`, then return
  - Otherwise:
    - Broadcast `propose(slot, x)`
    - Broadcast `ackPropose(slot, x)`

- Upon receiving `ackPropose(slot, x)`
  - Increase counter for `(slot, x)`, which is initially initialized to 0, by 1
  - If said counter reaches `n-f`, commit `x` and unlock `proposeHandler`
  - If too much time passes, unlock `proposeHandler`


Note that if we have a majority(`n-f`) of valid nodes, and one of which had sent `propose(slot, x)`, then eventually
all these nodes receive `propose(slot, x)`, and thus will `ackPropose(slot, x)`, thus each of them will also receive
`n-f` `ackPropose`s, resulting in them committing it.

## Dealing with races

Due to the locking mechanism, a node cannot handle two proposes at the same time. 
handling `propose(slot, x)`, he will not handle other proposes until committing `x` onto `slot`, or a timeout passes




## Safety

If any node committed `x` to slot `slot`, it implies at least `n-f` nodes did `ackPropose(slot, x)`, in particular,
at least one valid node had `ackPropose`d it, therefore it had also broadcast it to all nodes(in particular, all valid nodes)
therefore, all valid nodes had also `ackPropose`d it, resulting in each of them seeing at least `n-f` acks, resulting in
them committing `x` to `slot`.

So, if someone committed `x` to slot `slot`, all valid nodes did, and zero or more faulty nodes.

No two nodes can 

committed it, therefore, at least one valid node
has committed it. However, a valid node would've broadcast the proposal to all other valid nodes, who would commit it
as well


## Liveness

If a 


For liveness, 
 
Safety:

Note that if our node is crashed, or due to omissions, fails to send the request(directly/indirectly) to at least one valid node,
then the value won't be committed anywhere.(As f < n - f)
It is possible that the value is committed(e.g, if it was sent to a valid node), but the adversary omits
acks, so the value isn't committed. This is OK, as long as we ensure said node won't commit
any other value(uniform consensus)

Since we're in multi-slot, whenever a node tries to commit into a slot that was already committed, this will be relayed
back with an error(`Bad`) proposing a new slot, or `Ack` if we happen to commit the same value

Faulty nodes suffering from omission failures can act like valid nodes, which is no problem. Either way, we always expect
one valid node to receive an ack, thereby ensuring the propagation of success.

Races between (valid) nodes are possible, one node might succeed and others will fail - this will be resolved by
the failing node to try re-transmission. 

Liveness: 




